<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUNTRACK</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
    <!-- Custom styling for a minimal look -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff;
            color: #1a1a2e;
        }
        #app-name {
            font-family: 'Poppins', sans-serif;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen overflow-hidden">

    <div id="app-container" class="relative w-full h-full bg-white rounded-3xl p-6 flex flex-col items-center justify-center text-center space-y-4 md:space-y-6">

        <h1 id="app-name" class="text-3xl md:text-5xl font-bold text-gray-800">
            SUNTRACK
        </h1>
        <p class="text-sm md:text-base text-gray-600">Follow the arrow to find the sun!</p>

        <!-- Video and Canvas for the AR effect -->
        <div id="video-container" class="relative w-full h-full rounded-2xl overflow-hidden bg-black border-4 border-gray-300">
            <!-- object-contain ensures the video maintains its aspect ratio, preventing a squeezed look -->
            <video id="videoElement" playsinline autoplay muted class="absolute top-0 left-0 w-full h-full object-contain"></video>
            <canvas id="canvasElement" class="absolute top-0 left-0 w-full h-full"></canvas>
            
            <!-- This is now a clickable container to start the app -->
            <div id="startButton" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 bg-opacity-90 text-gray-700 font-semibold cursor-pointer transition-opacity duration-300">
                <p class="text-lg md:text-xl">Tap to Start AR</p>
                <p id="loadingMessage" class="text-sm md:text-base mt-2 hidden">Waiting for permissions...</p>
            </div>
            
            <!-- Dedicated button for GPS permission, now hidden by default -->
            <div id="gps-button" class="hidden absolute bottom-4 left-1/2 -translate-x-1/2">
                <button class="bg-gray-800 text-white py-2 px-4 rounded-full shadow-lg text-sm md:text-base hover:bg-gray-700 transition-colors">
                    Request GPS
                </button>
            </div>
        </div>

        <!-- Status messages -->
        <div id="status-container" class="w-full text-left text-sm md:text-base">
            <p id="camera-status" class="text-red-600">Camera: Denied</p>
            <!-- GPS status message is now a button to trigger permission requests -->
            <button id="gps-status" class="text-red-600 text-left w-full cursor-pointer">GPS: Denied</button>
            <p id="gyro-status" class="text-red-600">Gyro: Denied</p>
        </div>

    </div>

    <!-- SunCalc library for sun position calculation -->
    <script src="https://cdn.jsdelivr.net/npm/suncalc@1.8.0/suncalc.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get DOM elements
            const videoElement = document.getElementById('videoElement');
            const canvasElement = document.getElementById('canvasElement');
            const startButton = document.getElementById('startButton');
            const gpsButton = document.getElementById('gps-button');
            const loadingMessage = document.getElementById('loadingMessage');
            const cameraStatus = document.getElementById('camera-status');
            const gpsStatus = document.getElementById('gps-status');
            const gyroStatus = document.getElementById('gyro-status');
            const ctx = canvasElement.getContext('2d');

            // Global variables for sensor data
            let latitude = null;
            let longitude = null;
            let heading = 0; // Device heading (alpha)
            let pitch = 0; // Device tilt (beta)
            let roll = 0; // Device roll (gamma)

            // Track permission states
            let cameraPermissionGranted = false;
            let gpsPermissionGranted = false;
            let gyroPermissionGranted = false;

            // Assumed field of view for the camera in degrees (simplified)
            const horizontalFOV = 60;
            const verticalFOV = 45;

            // ---- Permission Handling and Setup ----

            // Function to request camera access
            async function setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment', // Use the back camera
                            width: { ideal: 1280 }, // Request higher resolution to favor the main camera
                            height: { ideal: 720 }
                        }
                    });
                    videoElement.srcObject = stream;
                    videoElement.play();
                    videoElement.onloadedmetadata = () => {
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                    };
                    cameraPermissionGranted = true;
                    cameraStatus.textContent = 'Camera: Active';
                    cameraStatus.classList.remove('text-red-600');
                    cameraStatus.classList.add('text-green-600');
                    console.log("Camera access granted.");
                    checkAllPermissions();
                } catch (err) {
                    cameraStatus.textContent = 'Camera: Denied';
                    console.error("Error accessing camera: ", err);
                    showError("Please allow camera access to use this application.");
                }
            }

            // Function to request GPS access
            function setupGPS() {
                // Ensure the GPS status button is clickable and styled correctly
                gpsStatus.textContent = 'GPS: Requesting...';
                gpsStatus.classList.remove('text-red-600');
                
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            latitude = position.coords.latitude;
                            longitude = position.coords.longitude;
                            gpsPermissionGranted = true;
                            gpsStatus.textContent = 'GPS: Active';
                            gpsStatus.classList.remove('text-red-600');
                            gpsStatus.classList.add('text-green-600');
                            console.log("GPS access granted.");
                            checkAllPermissions();
                        },
                        (error) => {
                            gpsStatus.textContent = 'GPS: Denied - Tap to Enable';
                            gpsStatus.classList.add('text-red-600', 'underline'); // Highlight the button to the user
                            console.error("Error accessing GPS: ", error);
                            showError("Please enable GPS for accurate sun position.");
                        }
                    );
                } else {
                    gpsStatus.textContent = 'GPS: Not Supported';
                    console.error("Geolocation is not supported by this browser.");
                }
            }

            // Function to handle device orientation (gyroscope)
            function setupGyro() {
                if (window.DeviceOrientationEvent) {
                    const handleOrientation = (event) => {
                        heading = event.alpha;
                        pitch = event.beta;
                        roll = event.gamma;
                    };

                    // Check for permission requirement on iOS devices
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation);
                                    gyroPermissionGranted = true;
                                    gyroStatus.textContent = 'Gyro: Active';
                                    gyroStatus.classList.remove('text-red-600');
                                    gyroStatus.classList.add('text-green-600');
                                    console.log("Gyroscope access granted.");
                                    checkAllPermissions();
                                } else {
                                    gyroStatus.textContent = 'Gyro: Denied';
                                    console.error("Permission for gyroscope denied.");
                                }
                            })
                            .catch(console.error);
                    } else {
                        // Non-iOS browsers
                        window.addEventListener('deviceorientation', handleOrientation);
                        gyroPermissionGranted = true;
                        gyroStatus.textContent = 'Gyro: Active';
                        gyroStatus.classList.remove('text-red-600');
                        gyroStatus.classList.add('text-green-600');
                        console.log("Gyroscope access granted (no permission prompt needed).");
                        checkAllPermissions();
                    }
                } else {
                    gyroStatus.textContent = 'Gyro: Not Supported';
                    console.error("Device orientation not supported.");
                }
            }

            // Main function to start the application after user interaction
            function startPermissionRequests() {
                startButton.style.display = 'none';
                loadingMessage.style.display = 'block'; // Show loading message
                // Use a short delay to ensure the user gesture is fully processed
                setTimeout(() => {
                    setupCamera();
                    setupGyro();
                    setupGPS();
                }, 300);
            }

            // Check if all permissions are granted before starting the AR loop
            function checkAllPermissions() {
                if (cameraPermissionGranted && gpsPermissionGranted && gyroPermissionGranted) {
                    startButton.style.display = 'none'; // Hide the start button
                    startArLoop();
                }
            }

            // ---- Main AR Loop ----

            function startArLoop() {
                function draw() {
                    // Draw the video frame onto the canvas
                    ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                    // Only proceed if we have GPS and Gyro data
                    if (latitude !== null && longitude !== null && heading !== null) {
                        const now = new Date();
                        const sunPosition = SunCalc.getSunPosition(now, latitude, longitude);

                        // Sun's azimuth in degrees (0-360)
                        const sunAzimuthDeg = (sunPosition.azimuth * 180 / Math.PI + 360) % 360;
                        // Sun's altitude in degrees (-90 to 90)
                        const sunAltitudeDeg = sunPosition.altitude * 180 / Math.PI;

                        // Calculate relative position based on device heading and sun's azimuth
                        let relativeAzimuth = sunAzimuthDeg - heading;
                        if (relativeAzimuth > 180) relativeAzimuth -= 360;
                        if (relativeAzimuth < -180) relativeAzimuth += 360;

                        // Calculate relative position based on device pitch and sun's altitude
                        let relativeAltitude = sunAltitudeDeg - (-pitch);

                        // Check if the sun is within the camera's field of view
                        if (Math.abs(relativeAzimuth) < horizontalFOV / 2 && Math.abs(relativeAltitude) < verticalFOV / 2) {
                            const x = (relativeAzimuth + horizontalFOV / 2) / horizontalFOV * canvasElement.width;
                            const y = (-relativeAltitude + verticalFOV / 2) / verticalFOV * canvasElement.height;
                            drawSunFlare(x, y);
                        } else {
                            // Sun is out of view, draw the guiding arrow
                            drawGuidingArrow(relativeAzimuth, relativeAltitude);
                        }
                    }

                    requestAnimationFrame(draw);
                }
                requestAnimationFrame(draw);
            }

            // ---- Drawing the Sun Effect ----

            function drawSunFlare(x, y) {
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 100);
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
                gradient.addColorStop(0.3, 'rgba(255, 200, 50, 0.5)');
                gradient.addColorStop(0.8, 'rgba(255, 100, 0, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 100, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            }

            // ---- Drawing the Guiding Arrow ----

            function drawGuidingArrow(relativeAzimuth, relativeAltitude) {
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const canvasWidth = canvasElement.width;
                const canvasHeight = canvasElement.height;
                const arrowSize = 40;
                const arrowPadding = 20;

                let x, y, rotation;
                const halfFOV_H = horizontalFOV / 2;
                const halfFOV_V = verticalFOV / 2;

                if (Math.abs(relativeAzimuth) >= halfFOV_H) {
                    if (relativeAzimuth > 0) {
                        x = canvasWidth - arrowPadding;
                        rotation = Math.PI / 2;
                    } else {
                        x = arrowPadding;
                        rotation = -Math.PI / 2;
                    }
                    y = ((relativeAltitude + halfFOV_V) / (halfFOV_V * 2)) * canvasHeight;
                    y = Math.min(Math.max(y, arrowPadding), canvasHeight - arrowPadding);
                } else {
                    if (relativeAltitude > 0) {
                        y = arrowPadding;
                        rotation = Math.PI;
                    } else {
                        y = canvasHeight - arrowPadding;
                        rotation = 0;
                    }
                    x = ((relativeAzimuth + halfFOV_H) / (halfFOV_H * 2)) * canvasWidth;
                    x = Math.min(Math.max(x, arrowPadding), canvasWidth - arrowPadding);
                }

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                ctx.fillStyle = 'rgba(255, 200, 0, 0.9)';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 200, 0, 0.7)';
                ctx.beginPath();
                ctx.moveTo(0, -arrowSize / 2);
                ctx.lineTo(arrowSize, 0);
                ctx.lineTo(0, arrowSize / 2);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // ---- Helper Functions ----

            function showError(message) {
                loadingMessage.textContent = message;
                loadingMessage.style.display = 'block';
                loadingMessage.classList.add('bg-red-900', 'bg-opacity-80');
            }
            
            // Add a click event listener to the start button
            startButton.addEventListener('click', startPermissionRequests);
            // This is the new, more direct way to trigger GPS permission
            gpsStatus.addEventListener('click', setupGPS);

        });
    </script>
</body>
</html>
