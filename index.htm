<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SunTrack AR - Working Solution</title>
  <style>
    /* Safe‐area / layout */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      overflow: hidden;
      background: #000; color: #fff;
      font-family: system-ui, sans-serif;
    }
    video {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; object-fit: cover;
      z-index: 1;
    }
    canvas#cv {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; object-fit: cover;
      z-index: 2;
    }
    /* Debug pane at top */
    #debug {
      position: fixed; top: env(safe-area-inset-top); left: 0; right: 0;
      height: 140px; background: rgba(0,0,0,0.8);
      color: #0f8; font-family: monospace; font-size: 12px;
      padding: 6px; overflow-y: auto; z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      margin: 0;
    }
    /* Controls at bottom */
    #controls {
      position: fixed; bottom: env(safe-area-inset-bottom); left: 0; right: 0;
      display: flex; gap: 6px; padding: 8px;
      background: rgba(0,0,0,0.7); z-index: 1000;
    }
    button {
      flex: 1; padding: 10px; font-size: 14px;
      background: #222; color: #fff; border: none; border-radius: 4px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.4; }
    
    /* Status indicator */
    #status-indicator {
      position: fixed;
      top: 150px;
      right: 20px;
      width: 120px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      z-index: 1000;
      font-size: 14px;
    }
    
    .status-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .status-value {
      color: #ffcc00;
      font-weight: bold;
    }
    
    /* Orientation indicator */
    #orientation-indicator {
      position: fixed;
      top: 200px;
      right: 20px;
      width: 100px;
      height: 100px;
      z-index: 1000;
      background: rgba(0,0,0,0.5);
      border-radius: 50%;
      transform: rotate(0deg);
    }
    .axis {
      position: absolute;
      transform-origin: center;
    }
    .axis-x {
      width: 2px;
      height: 100%;
      left: 50%;
      background: red;
    }
    .axis-y {
      width: 100%;
      height: 2px;
      top: 50%;
      background: green;
    }
    .axis-z {
      width: 100%;
      height: 100%;
      border: 1px dashed #0f8;
      border-radius: 50%;
      box-sizing: border-box;
    }
    
    /* Off-screen indicator */
    .off-screen-indicator {
      position: absolute;
      width: 40px;
      height: 40px;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
  </style>
</head>
<body>

  <video id="vid" playsinline autoplay muted></video>
  <canvas id="cv"></canvas>
  
  <div id="status-indicator">
    <div class="status-item">Status: <span id="status-value" class="status-value">Ready</span></div>
    <div class="status-item">Sun Az: <span id="sun-az-value" class="status-value">0°</span></div>
    <div class="status-item">Sun Alt: <span id="sun-alt-value" class="status-value">0°</span></div>
    <div class="status-item">Heading: <span id="heading-value" class="status-value">0°</span></div>
    <div class="status-item">Pitch: <span id="pitch-value" class="status-value">0°</span></div>
  </div>
  
  <div id="orientation-indicator">
    <div class="axis axis-x"></div>
    <div class="axis axis-y"></div>
    <div class="axis axis-z"></div>
  </div>

  <pre id="debug">[ready]\n</pre>

  <div id="controls">
    <button id="btnCam">Start Camera</button>
    <button id="btnGeo" disabled>Get Location</button>
    <button id="btnGyro" disabled>Enable Motion</button>
    <button id="btnAR" disabled>Start AR</button>
    <button id="btnCopy">Copy Logs</button>
  </div>

  <script>
    // —— DOM refs & state ——
    const vid = document.getElementById('vid');
    const cv  = document.getElementById('cv');
    const logEl = document.getElementById('debug');
    const orientationIndicator = document.getElementById('orientation-indicator');
    const statusValue = document.getElementById('status-value');
    const sunAzValue = document.getElementById('sun-az-value');
    const sunAltValue = document.getElementById('sun-alt-value');
    const headingValue = document.getElementById('heading-value');
    const pitchValue = document.getElementById('pitch-value');
    
    let stream, lat, lng, heading, pitch, roll;
    let sunPath = [], ctx2d;
    let lastOrientationLog = 0;
    let animationFrameId = null;
    let isARActive = false;

    // Field of view settings
    const HORIZONTAL_FOV = 60;  // degrees
    const VERTICAL_FOV = 45;    // degrees

    // —— Logging helper ——
    function log(...args) {
      logEl.textContent += args.join(' ') + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    // —— Sun math ——
    const rad = Math.PI/180, toDeg = 180/Math.PI;
    function toDays(date) {
      return date.getTime()/86400000 - 0.5 + 2440588 - 2451545;
    }
    function getSunPosition(date, lat, lng) {
      const lw  = rad*-lng, phi = rad*lat, d = toDays(date);
      const M   = rad*(357.5291 + .98560028*d);
      const C   = rad*(1.9148*Math.sin(M) + .02*Math.sin(2*M) + .0003*Math.sin(3*M));
      const L   = M + C + rad*280.4665;
      const dec = Math.asin(Math.sin(rad*23.44)*Math.sin(L));
      const ra  = Math.atan2(Math.cos(rad*23.44)*Math.sin(L), Math.cos(L));
      const J   = date.getTime()/86400000 + 2440587.5;
      const gst = (J-2451545.0)*.985647362 + 280.460618;
      const ha  = rad*(gst + lng) - ra;
      const alt = Math.asin(Math.sin(phi)*Math.sin(dec) + Math.cos(phi)*Math.cos(dec)*Math.cos(ha));
      const az  = Math.atan2(Math.sin(ha),
                    Math.cos(ha)*Math.sin(phi) - Math.tan(dec)*Math.cos(phi));
      return { azimuth:(az*toDeg+360)%360, altitude:alt*toDeg };
    }

    // —— 1) Camera ——
    document.getElementById('btnCam').onclick = async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video:{ 
            facingMode:'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }, 
          audio:false
        });
        vid.srcObject = stream;
        
        // Wait for video to load metadata
        await new Promise(resolve => {
          vid.onloadedmetadata = resolve;
        });
        
        log('✅ Camera OK - Dimensions:', vid.videoWidth, 'x', vid.videoHeight);
        statusValue.textContent = 'Camera Ready';
        document.getElementById('btnGeo').disabled = false;
      } catch (e) {
        log('❌ Camera ERR', e.name, e.message);
        statusValue.textContent = 'Camera Error';
      }
    };

    // —— 2) Geolocation ——
    document.getElementById('btnGeo').onclick = () => {
      if (!navigator.geolocation) return log('❌ No geolocation API');
      statusValue.textContent = 'Getting Location...';
      navigator.geolocation.getCurrentPosition(pos => {
        lat = pos.coords.latitude; 
        lng = pos.coords.longitude;
        log('✅ Geo OK', lat.toFixed(6), lng.toFixed(6));
        statusValue.textContent = 'Location Found';
        document.getElementById('btnGyro').disabled = false;
      }, err => {
        log('❌ Geo ERR', err.code, err.message);
        statusValue.textContent = 'Location Error';
      }, { enableHighAccuracy:true, timeout:10000 });
    };

    // —— 3) Device Motion ——
    function handleOri(e) {
      // Normalize heading
      heading = e.webkitCompassHeading != null
        ? e.webkitCompassHeading : (360 - e.alpha);
      
      // Normalize pitch (adjust for portrait orientation)
      pitch = e.beta - 90;
      
      // Normalize roll
      roll = e.gamma;
      
      // Clamp values
      if (heading > 360) heading -= 360;
      if (heading < 0) heading += 360;
      if (pitch > 180) pitch -= 360;
      if (pitch < -180) pitch += 360;
      
      // Update orientation indicator
      orientationIndicator.style.transform = `rotate(${heading}deg)`;
      
      // Update status display
      headingValue.textContent = heading.toFixed(1) + '°';
      pitchValue.textContent = pitch.toFixed(1) + '°';
      
      // Throttle logging
      const now = Date.now();
      if (now - lastOrientationLog > 1000) {
        log('↻ Motion', 
            'H:', heading.toFixed(1)+'°', 
            'P:', pitch.toFixed(1)+'°', 
            'R:', roll.toFixed(1)+'°');
        lastOrientationLog = now;
      }
    }
    
    document.getElementById('btnGyro').onclick = () => {
      statusValue.textContent = 'Requesting Motion...';
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
          if (state==='granted') {
            window.addEventListener('deviceorientation', handleOri);
            log('✅ Gyro OK');
            statusValue.textContent = 'Motion Enabled';
            document.getElementById('btnAR').disabled = false;
          } else {
            log('❌ Gyro DENIED');
            statusValue.textContent = 'Motion Denied';
          }
        }).catch(err => {
          log('❌ Gyro ERR', err);
          statusValue.textContent = 'Motion Error';
        });
      } else {
        window.addEventListener('deviceorientation', handleOri);
        log('✅ Gyro OK (no prompt)');
        statusValue.textContent = 'Motion Enabled';
        document.getElementById('btnAR').disabled = false;
      }
    };

    // —— Sun path compute ——
    function calculateSunPath() {
      sunPath = [];
      const now = new Date();
      for (let i=0; i<96; i++) {
        const t = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        t.setMinutes(i*15);
        sunPath.push(getSunPosition(t, lat, lng));
      }
      log(`🎯 Sun path: ${sunPath.length} points`);
    }

    // —— AR overlay draw ——
    function drawAR() {
      if (!ctx2d) return;
      
      // Clear canvas
      ctx2d.clearRect(0,0,cv.width,cv.height);
      
      // Calculate FOV values
      const halfH = HORIZONTAL_FOV / 2;
      const halfV = VERTICAL_FOV / 2;
      
      // Draw horizon line with roll compensation
      if (roll !== undefined) {
        // Calculate horizon position based on pitch
        const horizonY = cv.height * (0.5 - (pitch / (2 * halfV)));
        
        ctx2d.strokeStyle='rgba(255,255,255,0.8)'; 
        ctx2d.lineWidth=3;
        ctx2d.beginPath();
        
        // Apply roll to horizon line
        const centerX = cv.width / 2;
        const tiltAngle = roll * rad;
        const offsetY = Math.tan(tiltAngle) * centerX;
        
        ctx2d.moveTo(0, horizonY - offsetY);
        ctx2d.lineTo(cv.width, horizonY + offsetY);
        ctx2d.stroke();
        
        // Label the horizon
        ctx2d.fillStyle = "white";
        ctx2d.font = "bold 16px sans-serif";
        ctx2d.textAlign = "center";
        ctx2d.fillText("Horizon", cv.width/2, horizonY - 15);
      }
      
      // Draw sun path arc
      if (sunPath.length > 0) {
        ctx2d.strokeStyle='rgba(255,255,0,0.7)'; 
        ctx2d.lineWidth=3;
        ctx2d.beginPath();
        
        let firstPoint = true;
        
        sunPath.forEach((pt,i) => {
          // Calculate relative azimuth
          let relAz = pt.azimuth - heading;
          if (relAz > 180) relAz -= 360;
          if (relAz < -180) relAz += 360;
          
          // Calculate relative altitude
          let relAlt = pt.altitude - pitch;
          
          // Only draw if within FOV
          if (Math.abs(relAz) <= halfH && Math.abs(relAlt) <= halfV) {
            const x = ((relAz + halfH) / HORIZONTAL_FOV) * cv.width;
            const y = ((halfV - relAlt) / VERTICAL_FOV) * cv.height;
            
            if (firstPoint) {
              ctx2d.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx2d.lineTo(x, y);
            }
            
            // Add hour markers
            const hour = pt.time.getHours();
            if (hour % 3 === 0 && pt.time.getMinutes() === 0) {
              ctx2d.fillStyle = "yellow";
              ctx2d.font = "bold 12px sans-serif";
              ctx2d.textAlign = "center";
              ctx2d.fillText(`${hour}:00`, x, y - 18);
              ctx2d.beginPath();
              ctx2d.arc(x, y, 5, 0, Math.PI*2);
              ctx2d.fill();
            }
          }
        });
        
        ctx2d.stroke();
      }
      
      // Draw current sun position
      if (lat !== null && lng !== null) {
        const now = new Date();
        const sunPos = getSunPosition(now, lat, lng);
        
        // Update status display
        sunAzValue.textContent = sunPos.azimuth.toFixed(1) + '°';
        sunAltValue.textContent = sunPos.altitude.toFixed(1) + '°';
        
        // Calculate relative position
        let relAz = sunPos.azimuth - heading;
        if (relAz > 180) relAz -= 360;
        if (relAz < -180) relAz += 360;
        
        let relAlt = sunPos.altitude - pitch;
        
        // Calculate screen coordinates
        const sunX = ((relAz + halfH) / HORIZONTAL_FOV) * cv.width;
        const sunY = ((halfV - relAlt) / VERTICAL_FOV) * cv.height;
        
        // Check if sun is on screen
        const isSunVisible = sunX >= 0 && sunX <= cv.width && 
                             sunY >= 0 && sunY <= cv.height;
        
        if (isSunVisible) {
          // Draw sun with glow effect
          ctx2d.shadowColor = 'rgba(255, 200, 0, 0.7)';
          ctx2d.shadowBlur = 15;
          ctx2d.fillStyle = 'rgba(255, 200, 0, 1)';
          ctx2d.beginPath();
          ctx2d.arc(sunX, sunY, 15, 0, Math.PI * 2);
          ctx2d.fill();
          
          // Reset shadow
          ctx2d.shadowBlur = 0;
          
          // Label the sun
          ctx2d.fillStyle = "white";
          ctx2d.font = "bold 16px sans-serif";
          ctx2d.textAlign = "center";
          ctx2d.fillText("☀️ Sun", sunX, sunY - 25);
        } else {
          // Draw off-screen indicator
          const indicator = document.createElement('div');
          indicator.className = 'off-screen-indicator';
          indicator.innerHTML = '☀️';
          indicator.style.color = 'orange';
          
          // Position indicator at edge of screen pointing to sun
          let left = Math.max(20, Math.min(cv.width - 60, sunX));
          let top = Math.max(20, Math.min(cv.height - 60, sunY));
          
          // Position at edge of screen
          if (sunX < 0) left = 10;
          else if (sunX > cv.width) left = cv.width - 50;
          if (sunY < 0) top = 10;
          else if (sunY > cv.height) top = cv.height - 50;
          
          indicator.style.left = left + 'px';
          indicator.style.top = top + 'px';
          
          // Remove previous indicator if exists
          const prevIndicator = document.querySelector('.off-screen-indicator');
          if (prevIndicator) document.body.removeChild(prevIndicator);
          
          document.body.appendChild(indicator);
        }
      }
      
      // Draw center crosshair for reference
      ctx2d.strokeStyle = 'rgba(255, 0, 0, 0.5)';
      ctx2d.lineWidth = 1;
      ctx2d.beginPath();
      ctx2d.moveTo(cv.width/2, 0);
      ctx2d.lineTo(cv.width/2, cv.height);
      ctx2d.moveTo(0, cv.height/2);
      ctx2d.lineTo(cv.width, cv.height/2);
      ctx2d.stroke();
      
      // Draw center point
      ctx2d.fillStyle = 'red';
      ctx2d.beginPath();
      ctx2d.arc(cv.width/2, cv.height/2, 5, 0, Math.PI*2);
      ctx2d.fill();
      
      animationFrameId = requestAnimationFrame(drawAR);
    }

    // —— 4) Start AR ——
    document.getElementById('btnAR').onclick = () => {
      const ok = !!stream && lat != null;
      log(ok ? '🎉 All set — starting AR!' : '❌ Missing prerequisites');
      if (!ok) return;
      
      statusValue.textContent = 'Starting AR...';
      
      // Set canvas dimensions to match video
      cv.width  = vid.videoWidth || window.innerWidth;
      cv.height = vid.videoHeight || window.innerHeight;
      
      ctx2d = cv.getContext('2d');
      calculateSunPath();
      
      // Start AR rendering loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      isARActive = true;
      drawAR();
      statusValue.textContent = 'AR Active';
    };

    // —— Copy Logs ——
    document.getElementById('btnCopy').onclick = async () => {
      try {
        await navigator.clipboard.writeText(logEl.textContent);
        log('📋 Logs copied');
      } catch (e) {
        log('❌ Copy failed', e);
      }
    };
    
    // Cleanup when page closes
    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    });
  </script>
</body>
</html>
