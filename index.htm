<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SunTrack AR ‚Ä¢ Next-Sunset Path</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    video{z-index:0} canvas{z-index:1}
    #status{position:fixed;top:env(safe-area-inset-top);right:10px;background:rgba(0,0,0,.7);padding:6px 8px;border-radius:6px;font-size:13px;z-index:3}
    #branding{position:fixed;left:10px;bottom:10px;color:#bbb;font-size:11px;z-index:3}
    #controls{position:fixed;left:0;right:0;bottom:calc(env(safe-area-inset-bottom)+118px);display:flex;gap:6px;padding:8px;background:rgba(0,0,0,.65);z-index:3}
    #controls button{flex:1;padding:10px;border:0;border-radius:6px;background:#222;color:#fff;font-size:14px} #controls button:disabled{opacity:.45}
    #debug{position:fixed;left:0;right:0;bottom:env(safe-area-inset-bottom);max-height:110px;overflow:auto;margin:0;padding:6px;background:rgba(0,0,0,.85);color:#0f8;font:12px/1.25 ui-monospace,SFMono-Regular,Menlo,monospace;z-index:3;white-space:pre}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
</head>
<body>
  <video id="vid" playsinline autoplay muted></video>
  <canvas id="cv"></canvas>

  <div id="status">Ready</div>
  <div id="branding">o4-mini-high</div>

  <div id="controls">
    <button id="bCam">Start Camera</button>
    <button id="bGeo" disabled>Get Location</button>
    <button id="bGyro" disabled>Enable Motion</button>
    <button id="bAR" disabled>Start AR</button>
    <button id="bCopy">Copy Logs</button>
  </div>
  <pre id="debug">[ready]
</pre>

  <script>
    // ---------- DOM & logging ----------
    const $ = id => document.getElementById(id);
    const vid = $('vid'), cv = $('cv'), ctx = cv.getContext('2d');
    const status = $('status'), dbg = $('debug');
    const log = (...a)=>{ dbg.textContent += a.join(' ') + '\n'; dbg.scrollTop = dbg.scrollHeight; };

    // ---------- State ----------
    let stream;
    let lat=null, lng=null;
    let rawH=0, rawP=0, smoothH=0, smoothP=0;
    const SMOOTH = 0.12;
    const HFOV = 65; // approx iPhone 15 wide lens
    let vFOV = 45;   // computed from aspect each run
    let path = [];   // [{t, azN, altDeg}]
    let startBucket = 0;
    let raf;

    // ---------- Utils ----------
    const rad2deg = r => r * 180 / Math.PI;
    function sunAzFromNorthCW(posAzRad){
      // SunCalc azimuth: from SOUTH, positive to WEST.
      // Convert to: from NORTH, clockwise (0=N, 90=E, 180=S, 270=W).
      return (rad2deg(posAzRad) + 180 + 360) % 360;
    }
    function rel(a,b){ // shortest signed diff a-b in [-180,180]
      let d = a - b;
      d = (d + 540) % 360 - 180;
      return d;
    }
    function computeVFOV(){
      const w = cv.width || window.innerWidth;
      const h = cv.height || window.innerHeight;
      vFOV = 2 * Math.atan(Math.tan((HFOV/2)*Math.PI/180) * (h/w)) * 180/Math.PI;
    }

    // ---------- Camera ----------
    $('bCam').onclick = async () => {
      try {
        status.textContent = 'Opening camera‚Ä¶';
        stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
        vid.srcObject = stream;
        await vid.play();
        cv.width  = vid.videoWidth  || innerWidth;
        cv.height = vid.videoHeight || innerHeight;
        computeVFOV();
        status.textContent = 'Camera OK';
        log('‚úÖ Camera OK', cv.width+'√ó'+cv.height, 'vFOV‚âà', vFOV.toFixed(1));
        $('bGeo').disabled = false;
      } catch(e){
        log('‚ùå Camera ERR', e.message); status.textContent='Camera error';
      }
    };

    // ---------- Geolocation ----------
    $('bGeo').onclick = () => {
      status.textContent = 'Getting location‚Ä¶';
      navigator.geolocation.getCurrentPosition(p=>{
        lat = p.coords.latitude; lng = p.coords.longitude;
        status.textContent = 'Location OK';
        log('‚úÖ Geo OK', lat.toFixed(5), lng.toFixed(5));
        $('bGyro').disabled = false;
      }, err=>{
        log('‚ùå Geo ERR', err.message); status.textContent='Location error';
      }, { enableHighAccuracy:true, timeout:10000 });
    };

    // ---------- Orientation ----------
    function onOri(e){
      // heading: prefer iOS compass heading; else 360 - alpha
      const h = (e.webkitCompassHeading != null) ? e.webkitCompassHeading : (360 - (e.alpha ?? 0));
      const p = (e.beta ?? 0) - 90; // portrait tilt, 0 near horizon
      rawH = (h+360)%360; rawP = p;
      smoothH = smoothH*(1-SMOOTH) + rawH*SMOOTH;
      smoothP = smoothP*(1-SMOOTH) + rawP*SMOOTH;
      status.textContent = `H:${smoothH.toFixed(1)}¬∞  P:${smoothP.toFixed(1)}¬∞`;
    }
    $('bGyro').onclick = () => {
      status.textContent = 'Enabling motion‚Ä¶';
      if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(s=>{
          if (s === 'granted') {
            window.addEventListener('deviceorientation', onOri);
            $('bAR').disabled = false;
            status.textContent = 'Motion OK';
            log('‚úÖ Gyro OK');
          } else {
            status.textContent = 'Motion denied'; log('‚ùå Gyro DENIED');
          }
        }).catch(err=>{ status.textContent='Motion error'; log('‚ùå Gyro ERR', err); });
      } else {
        window.addEventListener('deviceorientation', onOri);
        $('bAR').disabled = false;
        status.textContent = 'Motion OK';
        log('‚úÖ Gyro OK (no prompt)');
      }
    };

    // ---------- Sun path (from now -> next sunset) ----------
    function buildPath(){
      path.length = 0;
      const now = new Date();

      // current 15-min bucket index for +Nh labeling stability
      startBucket = Math.round(now.getMinutes()/15) % 4;

      // figure out end sunset (today or tomorrow)
      const timesToday = SunCalc.getTimes(now, lat, lng);
      let end = timesToday.sunset;
      if (!end || now >= end) { // after sunset -> use tomorrow
        const tmr = new Date(now); tmr.setDate(now.getDate()+1);
        end = SunCalc.getTimes(tmr, lat, lng).sunset;
      }

      // start at "now" and sample every 5 minutes until end
      const t = new Date(now); t.setSeconds(0,0);
      while (t <= end) {
        const pos = SunCalc.getPosition(t, lat, lng);
        const azN = sunAzFromNorthCW(pos.azimuth);    // fixed conversion
        const alt = rad2deg(pos.altitude);
        path.push({ t: new Date(t), azN, alt });
        t.setMinutes(t.getMinutes()+5);
      }
      log('üéØ Path points:', path.length, 'until', end.toLocaleTimeString());
    }

    // ---------- Rendering ----------
    function draw(){
      const w = cv.width, h = cv.height;
      ctx.clearRect(0,0,w,h);

      const halfH = HFOV/2, halfV = vFOV/2;

      // horizon (pitch only for stability)
      const horizonY = (0.5 - (-smoothP)/halfV) * h;
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, horizonY); ctx.lineTo(w, horizonY); ctx.stroke();

      // path polyline ‚Äî break only when leaving FOV or azimuth wrap
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.95)';
      ctx.lineWidth = 3; ctx.beginPath();
      let drawing = false, prevRX = null;

      for (let i=0;i<path.length;i++){
        const pt = path[i];
        if (pt.alt <= 0) { // only daylight
          if (drawing){ ctx.stroke(); drawing=false; prevRX=null; }
          continue;
        }
        const rAz = rel(pt.azN, smoothH);
        const rAlt = pt.alt - smoothP;

        const inFOV = Math.abs(rAz) <= halfH && Math.abs(rAlt) <= halfV;
        if (!inFOV) {
          if (drawing){ ctx.stroke(); drawing=false; prevRX=null; }
          continue;
        }

        const x = (0.5 + rAz/HFOV) * w;
        const y = (0.5 - rAlt/vFOV) * h;

        // if we jumped a huge amount horizontally (wrap), restart
        if (drawing && prevRX !== null && Math.abs(x - prevRX) > w*0.25) {
          ctx.stroke(); ctx.beginPath(); drawing=false;
        }

        if (!drawing){ ctx.moveTo(x,y); drawing=true; }
        else { ctx.lineTo(x,y); }
        prevRX = x;
      }
      if (drawing) ctx.stroke();

      // hour labels: +Nh measured from current 15-min bucket
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';

      for (let i=0;i<path.length;i++){
        const pt = path[i];
        if (pt.alt <= 0) continue;

        // find nearest bucket for this point (0..3 within each hour)
        const minutes = pt.t.getMinutes();
        const bucket = Math.round(minutes/15) % 4;
        // label only points that share the *same bucket* as 'now'
        if (bucket !== startBucket) continue;

        const rAz = rel(pt.azN, smoothH);
        const rAlt = pt.alt - smoothP;
        if (Math.abs(rAz) > halfH || Math.abs(rAlt) > halfV) continue;

        const x = (0.5 + rAz/HFOV) * w;
        const y = (0.5 - rAlt/vFOV) * h;

        // hours ahead from now (rounded)
        const deltaH = Math.round( (pt.t - Date.now()) / 3600000 );
        if (deltaH < 0) continue; // future only
        ctx.fillText(`+${deltaH}h`, x, y - 8);
      }

      raf = requestAnimationFrame(draw);
    }

    // ---------- Start AR ----------
    $('bAR').onclick = () => {
      if (!stream || lat==null){ log('‚ùå Missing prerequisites'); return; }
      cv.width  = vid.videoWidth  || innerWidth;
      cv.height = vid.videoHeight || innerHeight;
      computeVFOV();
      buildPath();
      if (raf) cancelAnimationFrame(raf);
      draw();
      status.textContent = 'AR Active';
      log('üéâ AR started');
    };

    // ---------- Copy logs ----------
    $('bCopy').onclick = async () => {
      try { await navigator.clipboard.writeText(dbg.textContent); log('üìã Logs copied'); }
      catch(e){ log('‚ùå Copy failed', e.message); }
    };

    // ---------- Cleanup ----------
    window.addEventListener('beforeunload', ()=>{
      if (stream) stream.getTracks().forEach(t=>t.stop());
      if (raf) cancelAnimationFrame(raf);
    });
  </script>
</body>
</html>
