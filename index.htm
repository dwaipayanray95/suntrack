<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>SunTrack AR â€¢ Stable Path with Segments</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        #app-container {
            position: relative;
            width: 100%; height: 100%;
            background-color: #000;
        }
        video, canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
        }
        video { z-index: 0 }
        canvas { z-index: 1 }
        #overlay-ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            color: #fff;
            pointer-events: none;
        }
        /* Style for the debug log container */
        #debug {
            max-height: 120px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <video id="vid" playsinline autoplay muted></video>
        <canvas id="cv"></canvas>
        
        <div id="overlay-ui" class="flex flex-col h-full justify-between p-4">
            <!-- Status Display -->
            <div id="status" class="self-end px-4 py-2 bg-gray-900 bg-opacity-70 text-white text-sm md:text-base rounded-lg shadow-lg pointer-events-auto">
                Ready
            </div>

            <!-- UI Controls -->
            <div id="controls" class="flex flex-col items-center gap-2 pointer-events-auto">
                <div class="flex w-full justify-center gap-2">
                    <button id="btnCam" class="flex-1 max-w-[200px] bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-lg disabled:bg-gray-700 disabled:text-gray-400">
                        Start Camera
                    </button>
                    <button id="btnGeo" disabled class="flex-1 max-w-[200px] bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-lg disabled:bg-gray-700 disabled:text-gray-400">
                        Get Location
                    </button>
                </div>
                <div class="flex w-full justify-center gap-2">
                    <button id="btnGyro" disabled class="flex-1 max-w-[200px] bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-lg disabled:bg-gray-700 disabled:text-gray-400">
                        Enable Motion
                    </button>
                    <button id="btnAR" disabled class="flex-1 max-w-[200px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 shadow-lg disabled:bg-gray-700 disabled:text-gray-400">
                        Start AR
                    </button>
                </div>
                <button id="btnCopy" class="w-full max-w-[408px] bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg">
                    Copy Logs
                </button>
            </div>
            
            <!-- Debug Logs -->
            <pre id="debug" class="self-start mt-2 w-full p-2 md:p-4 bg-gray-900 bg-opacity-80 text-lime-400 font-mono text-xs md:text-sm rounded-lg shadow-lg pointer-events-auto">
                [ready]
            </pre>
        </div>
    </div>

    <script>
        // Get all necessary DOM elements
        const vid = document.getElementById('vid');
        const cv = document.getElementById('cv');
        const statusEl = document.getElementById('status');
        const dbgEl = document.getElementById('debug');
        const btnCam = document.getElementById('btnCam');
        const btnGeo = document.getElementById('btnGeo');
        const btnGyro = document.getElementById('btnGyro');
        const btnAR = document.getElementById('btnAR');
        const btnCopy = document.getElementById('btnCopy');

        // State variables
        let stream, lat = null, lng = null;
        let rawH = 0, rawP = 0, smoothH = 0, smoothP = 0;
        let sunPath = [], ctx, raf;
        const SMOOTH = 0.12; // Smoothing factor for motion
        const HFOV = 65; // Horizontal Field of View in degrees (approximation for iPhone 15 wide)

        // Utility function for logging messages to the debug console
        const log = (...messages) => {
            dbgEl.textContent += messages.join(' ') + '\n';
            dbgEl.scrollTop = dbgEl.scrollHeight;
        };

        // Function to update the canvas dimensions and handle window resize
        const resizeCanvas = () => {
            // Use fallback to window size if video dimensions aren't available yet
            cv.width = vid.videoWidth || window.innerWidth;
            cv.height = vid.videoHeight || window.innerHeight;
            if (ctx) {
                // If AR is active, redraw the sun path after resize
                draw();
            }
        };
        window.addEventListener('resize', resizeCanvas);


        // --- Button Event Listeners ---

        // 1) Start Camera
        btnCam.addEventListener('click', async () => {
            try {
                statusEl.textContent = 'Opening camera...';
                // Request camera access for the environment-facing camera
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false
                });
                vid.srcObject = stream;
                await vid.play();
                statusEl.textContent = 'Camera OK';
                log('âœ… Camera OK');
                btnCam.disabled = true;
                btnGeo.disabled = false;
                resizeCanvas(); // Set initial canvas size
            } catch (e) {
                statusEl.textContent = 'Camera error';
                log('âŒ Camera ERR', e.message);
            }
        });

        // 2) Get Geolocation
        btnGeo.addEventListener('click', async () => {
            statusEl.textContent = 'Getting location...';
            
            try {
                // Use the Permissions API to check the state first
                const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });

                if (permissionStatus.state === 'granted') {
                    log('âœ… Geo permission granted');
                    getAndSetLocation();
                } else if (permissionStatus.state === 'prompt') {
                    log('ðŸ¤” Geo permission pending...');
                    // Calling getCurrentPosition() will trigger the prompt
                    getAndSetLocation();
                } else if (permissionStatus.state === 'denied') {
                    statusEl.textContent = 'Location denied';
                    log('âŒ Geo permission DENIED');
                }
            } catch (error) {
                statusEl.textContent = 'Permission error';
                log('âŒ Permission check ERR', error.message);
            }
        });

        const getAndSetLocation = () => {
            navigator.geolocation.getCurrentPosition(p => {
                lat = p.coords.latitude;
                lng = p.coords.longitude;
                statusEl.textContent = 'Location OK';
                log('âœ… Geo OK', lat.toFixed(5), lng.toFixed(5));
                btnGeo.disabled = true;
                btnGyro.disabled = false;
            }, e => {
                statusEl.textContent = 'Location error';
                log('âŒ Geo ERR', e.message);
            }, {
                enableHighAccuracy: true,
                timeout: 10000
            });
        };

        // 3) Enable Device Orientation (Gyro/Compass)
        const onDeviceOrientation = (e) => {
            // Determine heading (yaw) and pitch from device orientation event
            // webkitCompassHeading is for older iOS; alpha is standard
            const h = e.webkitCompassHeading != null ? e.webkitCompassHeading : (360 - e.alpha);
            const p = e.beta - 90; // Adjust pitch so 0 is level
            
            rawH = h;
            rawP = p;
            
            // Apply exponential smoothing to reduce jitter
            smoothH = smoothH * (1 - SMOOTH) + rawH * SMOOTH;
            smoothP = smoothP * (1 - SMOOTH) + rawP * SMOOTH;
            
            statusEl.textContent = `H:${smoothH.toFixed(1)}Â° P:${smoothP.toFixed(1)}Â°`;
            
            // Log a status message periodically
            if (!onDeviceOrientation.last || Date.now() - onDeviceOrientation.last > 800) {
                log('â†» H:', smoothH.toFixed(1) + 'Â°', 'P:', smoothP.toFixed(1) + 'Â°');
                onDeviceOrientation.last = Date.now();
            }
        };

        btnGyro.addEventListener('click', () => {
            statusEl.textContent = 'Enabling motion...';
            // Request permission for iOS 13+ devices
            if (DeviceOrientationEvent.requestPermission) {
                DeviceOrientationEvent.requestPermission().then(s => {
                    if (s === 'granted') {
                        window.addEventListener('deviceorientation', onDeviceOrientation);
                        statusEl.textContent = 'Motion OK';
                        log('âœ… Gyro OK');
                        btnGyro.disabled = true;
                        btnAR.disabled = false;
                    } else {
                        statusEl.textContent = 'Motion denied';
                        log('âŒ Gyro DENIED');
                    }
                }).catch(e => {
                    statusEl.textContent = 'Motion error';
                    log('âŒ Gyro ERR', e.message);
                });
            } else {
                // For non-iOS devices, just add the listener
                window.addEventListener('deviceorientation', onDeviceOrientation);
                statusEl.textContent = 'Motion OK';
                log('âœ… Gyro OK');
                btnGyro.disabled = true;
                btnAR.disabled = false;
            }
        });
        
        // Copy logs
        btnCopy.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(dbgEl.textContent);
                log('ðŸ“‹ Logs copied');
            } catch (err) {
                log('âŒ Failed to copy logs', err);
            }
        });


        // --- AR Logic ---

        // Compute the sun's path for the current day
        const computeSunPath = () => {
            sunPath = [];
            const now = new Date();
            // Iterate through every 15 minutes of the day
            for (let i = 0; i < 96; i++) {
                const t = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                t.setMinutes(i * 15);
                const pos = SunCalc.getPosition(t, lat, lng);
                sunPath.push({
                    az: (pos.azimuth * 180 / Math.PI + 360) % 360, // Azimuth in degrees (0-360)
                    alt: pos.altitude * 180 / Math.PI, // Altitude in degrees
                    time: t
                });
            }
            log('ðŸŽ¯ Sun path points:', sunPath.length);
        };

        // Main drawing loop
        const draw = () => {
            if (!ctx) return;
            ctx.clearRect(0, 0, cv.width, cv.height);

            const w = cv.width;
            const h = cv.height;

            // Calculate Vertical Field of View (VFOV) based on HFOV and aspect ratio
            const vFOV = 2 * Math.atan(Math.tan((HFOV / 2) * Math.PI / 180) * (h / w)) * 180 / Math.PI;
            const halfH = HFOV / 2;
            const halfV = vFOV / 2;

            // Draw a white horizon line
            const y0 = (0.5 - (-smoothP) / vFOV) * h;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, y0);
            ctx.lineTo(w, y0);
            ctx.stroke();

            // Draw the sun path
            ctx.strokeStyle = '#FFD700'; // Gold color for the sun path
            ctx.lineWidth = 4;
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            
            // Loop through sun path points to draw the line
            let lastPointWasVisible = false;
            sunPath.forEach((pt, i) => {
                // Calculate relative azimuth and altitude based on device orientation
                let rAz = pt.az - smoothH;
                if (rAz > 180) rAz -= 360;
                if (rAz < -180) rAz += 360;
                const rAlt = pt.alt - smoothP;

                const isVisible = Math.abs(rAz) <= halfH && Math.abs(rAlt) <= halfV;

                if (isVisible) {
                    const x = (0.5 + rAz / HFOV) * w;
                    const y = (0.5 - rAlt / vFOV) * h;
                    if (!lastPointWasVisible && i > 0) {
                        // This is the first visible point of a new segment
                        ctx.moveTo(x, y);
                    } else {
                        // Continue drawing the line
                        ctx.lineTo(x, y);
                    }
                    lastPointWasVisible = true;
                } else {
                    // If a point goes out of view, stroke the current path and reset
                    if (lastPointWasVisible) {
                        ctx.stroke();
                        ctx.beginPath(); // Start a new path for the next visible segment
                    }
                    lastPointWasVisible = false;
                }
            });
            ctx.stroke(); // Ensure the final segment is stroked
            ctx.shadowBlur = 0; // Reset shadow for other drawings

            // Draw time labels every hour
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            sunPath.forEach(pt => {
                if (pt.time.getMinutes() === 0) {
                    let rAz = pt.az - smoothH;
                    if (rAz > 180) rAz -= 360;
                    if (rAz < -180) rAz += 360;
                    const rAlt = pt.alt - smoothP;

                    // Check if the point is within the camera's view
                    if (Math.abs(rAz) <= halfH && Math.abs(rAlt) <= halfV) {
                        const x = (0.5 + rAz / HFOV) * w;
                        const y = (0.5 - rAlt / vFOV) * h;
                        ctx.fillText(`${pt.time.getHours()}:00`, x, y - 10);
                    }
                }
            });

            // Draw a marker for the current sun position
            const now = new Date();
            const currentPos = SunCalc.getPosition(now, lat, lng);
            let currentRAz = (currentPos.azimuth * 180 / Math.PI + 360) % 360 - smoothH;
            if (currentRAz > 180) currentRAz -= 360;
            if (currentRAz < -180) currentRAz += 360;
            const currentRAlt = currentPos.altitude * 180 / Math.PI - smoothP;

            if (Math.abs(currentRAz) <= halfH && Math.abs(currentRAlt) <= halfV) {
                const x = (0.5 + currentRAz / HFOV) * w;
                const y = (0.5 - currentRAlt / vFOV) * h;
                
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI); // Draw a circle
                ctx.fillStyle = '#FF4500'; // Orange-red color
                ctx.fill();
                ctx.shadowColor = '#FF4500';
                ctx.shadowBlur = 10;
            }
            ctx.shadowBlur = 0; // Reset shadow

            // Request the next animation frame
            raf = requestAnimationFrame(draw);
        };

        // 4) Start AR
        btnAR.addEventListener('click', () => {
            if (!stream || lat === null) {
                log('âŒ Missing prerequisites');
                return;
            }
            statusEl.textContent = 'Starting AR';
            ctx = cv.getContext('2d');
            computeSunPath();
            
            // If an animation is already running, cancel it
            if (raf) {
                cancelAnimationFrame(raf);
            }
            draw();
            statusEl.textContent = 'AR Active';
            log('ðŸŽ‰ AR started');
            btnAR.disabled = true;
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) stream.getTracks().forEach(t => t.stop());
            if (raf) cancelAnimationFrame(raf);
        });

    </script>
</body>
</html>
